# Kata [ID]: [Title of the Challenge]

**Target Idioms:** [e.g. Concurrency Patterns, Interface Pollution, Error Wrapping]
**Difficulty:** [ðŸŸ¢ Beginner / ðŸŸ¡ Intermediate / ðŸ”´ Advanced]

## ðŸ§  The "Why"
*Briefly explain the mismatch seasoned devs would face here. Why would the "Java way" or "Python way" fail in Go for this specific problem?*

## ðŸŽ¯ The Scenario
*[Describe a realistic production problem. Example: "You are building a CLI that parses 1GB logs..."]*

## ðŸ›  The Challenge
Implement a solution that satisfies the following requirements.

### 1. Functional Requirements
* [ ] [Requirement A]
* [ ] [Requirement B]

### 2. The "Idiomatic" Constraints (Pass/Fail Criteria)
*To pass this kata, you **must** use the following patterns:*
* [ ] **Constraint 1:** [e.g. Do not allocate new memory inside the loop.]
* [ ] **Constraint 2:** [e.g. Use `functional options` for configuration.]
* [ ] **Constraint 3:** [e.g. Return wrapped errors.]

## ðŸ§ª Self-Correction (Test Yourself)
* **If you did X:** [Explain why this is "un-idiomatic" or dangerous in Go]
* **Instead, ensure Y:** [Explain the idiomatic fix]

## ðŸ“š Resources
* [Link to Go Blog or Spec]